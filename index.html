<!DOCTYPE html><html lang="ar">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>تنبؤ بيتكوين للساعة القادمة — حي (BTC/USDT)</title>
  <style>
    body{font-family: Inter, Arial, sans-serif;direction:rtl;max-width:980px;margin:18px auto;padding:18px;background:#f6f8fb;color:#111}
    h1{text-align:center;margin-bottom:6px}
    .card{background:#fff;border-radius:12px;padding:14px;margin:12px 0;box-shadow:0 6px 18px rgba(17,24,39,0.06)}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .big{font-size:1.5rem;font-weight:700}
    .muted{color:#666}
    .good{color:green}
    .bad{color:#c0392b}
    .neutral{color:#444}
    #chart{height:260px}
    button{padding:8px 12px;border-radius:8px;border:0;background:#1f6feb;color:white;cursor:pointer}
    pre{white-space:pre-wrap}
  </style>
</head>
<body>
  <h1>تنبؤ بيتكوين للساعة القادمة (BTC/USDT)</h1>  <div id="status" class="card">جارِ التحضير...</div>  <div id="main" style="display:none">
    <div class="card row">
      <div style="flex:1">
        <div class="muted">السعر الحالي</div>
        <div class="big" id="price">-</div>
        <div class="muted">تحديث: <span id="lastUpdate">-</span></div>
      </div>
      <div style="width:320px">
        <div class="muted">الوقت المتبقي للساعة القادمة</div>
        <div id="countdown" class="big">--:--</div>
        <div style="margin-top:8px"><button id="recalc">أعد الحساب الآن</button></div>
      </div>
    </div><div class="card">
  <div class="muted">المؤشرات (الساعة - بيانات 1 دقيقة)</div>
  <div class="row" style="margin-top:10px">
    <div style="flex:1">RSI(14m): <span id="rsi" class="neutral">-</span></div>
    <div style="flex:1">MACD: <span id="macd" class="neutral">-</span></div>
    <div style="flex:1">Std(min): <span id="std" class="neutral">-</span></div>
  </div>
</div>

<div class="card">
  <div class="muted">الاحتمالات للساعة القادمة (نهاية الـ60 دقيقة)</div>
  <div style="margin-top:10px" id="probabilities">
    <div>احتمال الارتفاع (السعر النهائي &gt; السعر الحالي): <strong id="pUp">-</strong></div>
    <div>احتمال الهبوط (السعر النهائي &lt; السعر الحالي): <strong id="pDown">-</strong></div>
    <div>متوسط الزيادة المتوقعة: <strong id="meanReturn">-</strong></div>
  </div>
</div>

<div class="card">
  <div class="muted">محاكاة عيّنة (بعض المسارات)</div>
  <pre id="sample" style="height:150px;overflow:auto">-</pre>
</div>

<div class="card muted">
  ملاحظات: النموذج يستخدم محاكاة مونتي كارلو بسيطة مبنية على خواص العائدات اللحظية (فرضية حركة هندسية عشوائية). هذه نتيجة إحصائية تقريبية وليست نصيحة استثمارية.
</div>

  </div><script>
// ------------------ إعدادات ------------------
const SYMBOL = 'BTCUSDT';
const INTERVAL = '1m';            // مصدر بيانات 1 دقيقة
const HISTORY_MINUTES = 180;      // نأخذ آخر 180 دقيقة لتقدير المعلمات
const MC_SIMULATIONS = 2000;      // عدد محاكاة مونتي كارلو
const MC_STEPS = 60;              // خطوات للتحرك ساعة (60 دقيقة)

// ------------------ دوال مساعدة ------------------
function nowISO(){ return new Date().toLocaleString(); }
function mean(arr){ return arr.reduce((a,b)=>a+b,0)/arr.length }
function stddev(arr,mu){const m=mu===undefined?mean(arr):mu; return Math.sqrt(arr.reduce((s,x)=>s+Math.pow(x-m,2),0)/(arr.length-1)) }

// حساب RSI بسيط (على عوائد بالـ close-to-close)
function calcRSI(closes, period=14){
  if(closes.length<=period) return null;
  const deltas=[]; for(let i=1;i<closes.length;i++) deltas.push(closes[i]-closes[i-1]);
  let gains=0,losses=0;
  for(let i=0;i<period;i++){ const d=deltas[deltas.length-1-period+i]; if(d>0) gains+=d; else losses-=d }
  let avgGain=gains/period; let avgLoss=losses/period; if(avgLoss===0) return 100; const rs=avgGain/avgLoss; return 100-(100/(1+rs));
}

// MACD (EMA12 - EMA26) simplified
function ema(series,period){ const k=2/(period+1); let emaArr=[]; let start=mean(series.slice(0,period)); emaArr[period-1]=start; for(let i=period;i<series.length;i++){ emaArr[i]=(series[i]*k)+(emaArr[i-1]*(1-k)); } return emaArr }
function calcMACD(closes){ if(closes.length<26) return null; const ema12=ema(closes,12); const ema26=ema(closes,26); const macdLine=[]; for(let i=25;i<closes.length;i++){ macdLine.push(ema12[i]-ema26[i]) } // signal 9 ema of macd
  if(macdLine.length<9) return {macd:macdLine[macdLine.length-1]||0,signal:0};
  const signalArr=ema(macdLine,9); const lastIdx=signalArr.length-1; return {macd:macdLine[macdLine.length-1], signal: signalArr[lastIdx]}; }

// محاكاة مونتي كارلو على أساس المعلمة mu (متوسط العائد لكل دقيقة) و sigma
function monteCarloProbability(S0, mu, sigma, steps=MC_STEPS, sims=MC_SIMULATIONS){
  const dt=1; // كل خطوة = 1 minute
  let upCount=0; let samples=[];
  for(let s=0;s<sims;s++){
    let S=S0;
    const path=[];
    for(let t=0;t<steps;t++){
      const z = gaussianRandom();
      // نموذج GBM (تقريبي) باستخدام returns additive on log
      const ret = (mu - 0.5*sigma*sigma)*dt + sigma*Math.sqrt(dt)*z; // log-return
      S = S * Math.exp(ret);
      path.push(S);
    }
    samples.push(path);
    if(samples[s][samples[s].length-1] > S0) upCount++;
  }
  return {pUp: upCount / sims, samples};
}

// مولد أعداد عشوائية موزعة طبيعياً (Box-Muller)
function gaussianRandom(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2.0*Math.log(u))*Math.cos(2*Math.PI*v); }

// ------------------ جلب البيانات التاريخية (REST) ------------------
async function fetchHistoricalKlines(symbol='BTCUSDT', interval='1m', limit=500){
  const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const resp = await fetch(url);
  if(!resp.ok) throw new Error('REST fetch failed: '+resp.status);
  const data = await resp.json();
  // each kline: [ openTime, open, high, low, close, ... ]
  return data.map(k=>({t:k[0], close: parseFloat(k[4])}));
}

// ------------------ WebSocket للبث الحي (تجنب مشاكل CORS على REST للـ realtime)
let ws=null;
function connectWebsocket(symbol='btcusdt', interval='1m', onKline){
  const stream = `${symbol}@kline_${interval}`;
  const url = `wss://stream.binance.com:9443/ws/${stream}`;
  ws = new WebSocket(url);
  ws.onopen = ()=> console.log('WS open');
  ws.onmessage = (evt)=>{
    try{
      const msg = JSON.parse(evt.data);
      if(msg.k){ const k = msg.k; const close = parseFloat(k.c); const isFinal = k.x; onKline({close, isFinal, t:k.t}); }
    }catch(e){console.error(e)}
  };
  ws.onclose = ()=> console.log('WS closed');
  ws.onerror = e=> console.error('WS err', e);
}

// ------------------ التدفق الرئيسي ------------------
let closes=[]; // سلسلة أسعار دقيقة
async function start(){
  const statusEl = document.getElementById('status');
  try{
    statusEl.textContent = 'جاري جلب البيانات التاريخية من Binance...';
    // نحاول جلب آخر HISTORY_MINUTES + extra
    const history = await fetchHistoricalKlines(SYMBOL, INTERVAL, Math.min(1000, HISTORY_MINUTES+20));
    closes = history.map(d=>d.close);
    statusEl.textContent = 'تم جلب البيانات التاريخية. الاتصال بالبث الحي...';

    // تابع WebSocket لتحديث آخر سعر مباشرة
    connectWebsocket(SYMBOL.toLowerCase(), INTERVAL, (kline)=>{
      // عندما تكون الشمعة الحالية متغيرة (not final) سنحدّث آخر سعر، وعندما تكون final نضيف إلى closes
      const lastClose = closes[closes.length-1];
      if(kline.isFinal){ closes.push(kline.close); if(closes.length>1000) closes.shift(); }
      else { // غير نهائي: نعرض قيمة مباشرة (لا نضيفها للسلسلة التاريخية حتى تصبح نهائية)
        // لكن نريد عرضها للمستخدم
      }
      updateUI(kline.close);
    });

    statusEl.style.display = 'none';
    document.getElementById('main').style.display = 'block';

    // أول تحليل وحساب
    await analyzeAndSimulate();

    // زر إعادة الحساب
    document.getElementById('recalc').onclick = analyzeAndSimulate;

    // عداد
    startCountdown();
  }catch(err){
    statusEl.textContent = 'فشل في جلب البيانات: ' + err.message + '\n
إذا واجهت مشكلة CORS جرب تشغيل الملف عبر GitHub Pages أو خادم محلي.';
    statusEl.style.color = 'red';
    console.error(err);
  }
}

async function analyzeAndSimulate(){
  try{
    const latestPrice = closes[closes.length-1];
    document.getElementById('price').textContent = '$' + latestPrice.toFixed(2);
    document.getElementById('lastUpdate').textContent = nowISO();

    // نعمل على عوائد دقيقة (log returns) من آخر N دقائق
    const windowSize = Math.min(closes.length, HISTORY_MINUTES);
    const recent = closes.slice(closes.length - windowSize);
    const returns = [];
    for(let i=1;i<recent.length;i++) returns.push(Math.log(recent[i]/recent[i-1]));
    const mu = mean(returns); const sigma = stddev(returns, mu);

    // مؤشرات
    const rsi = calcRSI(recent);
    const macdObj = calcMACD(recent);
    document.getElementById('rsi').textContent = (rsi? rsi.toFixed(2) : '-') ;
    document.getElementById('macd').textContent = (macdObj? macdObj.macd.toFixed(4) + ' / ' + (macdObj.signal?macdObj.signal.toFixed(4):'-') : '-');
    document.getElementById('std').textContent = (sigma? (sigma*100).toFixed(4)+'%' : '-');

    // محاكاة مونتي كارلو (log-returns)
    const mc = monteCarloProbability(latestPrice, mu, sigma, MC_STEPS, MC_SIMULATIONS);
    const pUp = mc.pUp; const pDown = 1 - pUp; // لاحقا نحسب stable كنطاق +/- small

    // نحتسب احتمال "ثبات" كنسبة من المسارات التي تبقى ضمن ±0.1% من السعر الأصلي
    const tol = 0.001; // 0.1%
    let stableCount=0; let meanFinalReturns=0;
    for(const path of mc.samples){ const final = path[path.length-1]; const r = final/latestPrice - 1; meanFinalReturns += r; if(Math.abs(r) <= tol) stableCount++; }
    meanFinalReturns /= mc.samples.length;
    const pStable = stableCount / mc.samples.length;

    // عرض
    document.getElementById('pUp').textContent = (pUp*100).toFixed(2) + '%';
    document.getElementById('pDown').textContent = ((1-pUp-pStable)*100).toFixed(2) + '% (هبوط كبير)';
    document.getElementById('meanReturn').textContent = (meanFinalReturns*100).toFixed(3) + '% (متوقع)';

    // عينات عرضية
    const sampleEl = document.getElementById('sample');
    sampleEl.textContent = mc.samples.slice(0,6).map(p=>p.map(x=>x.toFixed(2)).join(', ')).join('\n\n');
  }catch(err){ console.error('analyze error', err); }
}

function startCountdown(){ function update(){ const now=new Date(); const next=new Date(now); next.setMinutes(next.getMinutes()+1); next.setSeconds(0); next.setMilliseconds(0); const diff=next-now; const s=Math.floor(diff/1000); document.getElementById('countdown').textContent = s + ' ثانية حتى الدقيقة القادمة'; }
  update(); setInterval(update,1000);
}

// بدء التشغيل
start();
</script></body>
  </html>
